/**
 * Gate API v4
 * Welcome to Gate.io API  APIv4 provides spot, margin and futures trading operations. There are public APIs to retrieve the real-time market statistics, and private APIs which needs authentication to trade on user\'s behalf.
 *
 * Contact: support@mail.gate.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* eslint-disable @typescript-eslint/no-floating-promises */

import { Authentication, GateApiV4Auth, HttpBasicAuth, HttpBearerAuth, OAuth, ObjectSerializer } from '../model/models';

import JSONBig from 'json-bigint';
import globalAxios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

export class ApiClient {
    protected _basePath = 'https://api.gateio.ws/api/v4';
    protected _defaultHeaders: any = {};

    protected authentications: { [key: string]: Authentication } = {
        apiv4: new GateApiV4Auth(),
    };

    constructor(basePath?: string, protected axiosInstance: AxiosInstance = globalAxios) {
        this._basePath = basePath || this._basePath;

        this.axiosInstance.defaults.transformResponse = [
            (data) => {
                try {
                    return JSONBig.parse(data);
                } catch (error) {
                    console.error('Failed to parse JSON:', error);
                    return data;
                }
            },
        ];
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    public setApiKeySecret(key: string, secret: string) {
        const auth = this.authentications['apiv4'] as GateApiV4Auth;
        auth.key = key;
        auth.secret = secret;
    }

    public async applyToRequest(config: AxiosRequestConfig, authSettings: Array<string>): Promise<AxiosRequestConfig> {
        for (const auth of authSettings) {
            const authenticator = this.authentications[auth];
            if (authenticator) {
                config = await authenticator.applyToRequest(config);
            }
        }
        return config;
    }

    public async request<T>(
        config: AxiosRequestConfig,
        responseType: string,
        authSettings: Array<string>,
    ): Promise<{ response: AxiosResponse; body: T }> {
        return Promise.resolve(config)
            .then((c) => this.applyToRequest(c, authSettings))
            .then((c) => {
                return this.axiosInstance.request(c).then((rsp) => {
                    let body = rsp.data;
                    if (responseType.length > 0) {
                        body = ObjectSerializer.deserialize(rsp.data, responseType);
                    }
                    return { response: rsp, body: body };
                });
            });
    }

    public async getAuthHeader(
        timestamp: string,
        method: string,
        path: string,
        queryString: string,
        data: string,
    ): Promise<{ key: string; timestamp: string; sign: string }> {
        const auth = this.authentications['apiv4'] as GateApiV4Auth;
        let signature: string;
        if (typeof window === 'undefined') {
            // NodeJS environment
            const crypto = await import('crypto');
            const hashedPayload = crypto.createHash('sha512').update(data).digest('hex');
            const signatureString = [method, path, queryString, hashedPayload, timestamp].join('\n');
            signature = crypto.createHmac('sha512', auth.secret).update(signatureString).digest('hex');
        } else {
            const crypto = await import('../utils/crypto');
            const hashedPayload = (await crypto.createHash('sha512').update(data).digest('hex')) as string;
            const signatureString = [method, path, queryString, hashedPayload, timestamp].join('\n');
            signature = (await crypto
                .createHmac('sha512', auth.secret)
                .update(signatureString)
                .digest('hex')) as string;
        }
        return {
            key: auth.key,
            timestamp,
            sign: signature,
        };
    }
}
