/**
 * Gate API v4
 * Welcome to Gate.io API  APIv4 provides spot, margin and futures trading operations. There are public APIs to retrieve the real-time market statistics, and private APIs which needs authentication to trade on user\'s behalf.
 *
 * Contact: support@mail.gate.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* eslint-disable @typescript-eslint/no-floating-promises */

import { Authentication, GateApiV4Auth, HttpBasicAuth, HttpBearerAuth, OAuth, ObjectSerializer } from '../model/models';

import JSONBig from 'json-bigint';

export interface RequestConfig {
    url?: string;
    method?: string;
    headers?: Record<string, string>;
    params?: Record<string, string>;
    auth?: { username: string; password: string };
    responseType?: 'arraybuffer' | 'document' | 'json' | 'text' | 'stream';
    data?: any;
}

export class ApiClient {
    protected _basePath = 'https://api.gateio.ws/api/v4';
    protected _defaultHeaders: any = {};

    protected authentications: { [key: string]: Authentication } = {
        apiv4: new GateApiV4Auth(),
    };

    constructor(basePath?: string) {
        this._basePath = basePath || this._basePath;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    public setApiKeySecret(key: string, secret: string) {
        const auth = this.authentications['apiv4'] as GateApiV4Auth;
        auth.key = key;
        auth.secret = secret;
    }

    public async applyToRequest(config: RequestConfig, authSettings: Array<string>): Promise<RequestConfig> {
        for (const auth of authSettings) {
            const authenticator = this.authentications[auth];
            if (authenticator) {
                config = await authenticator.applyToRequest(config);
            }
        }
        return config;
    }

    public async request<T>(
        config: RequestConfig,
        responseType: string,
        authSettings: Array<string>,
    ): Promise<{ response: Response; body: T }> {
        config = await this.applyToRequest(config, authSettings);
        const response: Response = await this.fetch(config);

        let body = JSONBig.parse(await response.text());
        if (responseType.length > 0) {
            body = ObjectSerializer.deserialize(body, responseType);
        }
        return { response, body: body };
    }

    private async fetch(config: RequestConfig): Promise<Response> {
        let url = config.url;
        if (url === undefined) {
            throw new Error('Invalid URL');
        }

        if (config.params) {
            const params =
                config.params instanceof URLSearchParams ? config.params : new URLSearchParams(config.params);
            const qs = params.toString();
            if (qs !== '') {
                url = `${url}?${qs}`;
            }
        }

        const request = new Request(url, {
            method: config.method ?? 'GET',
            headers: config.headers,
            body: typeof config.data === 'string' ? config.data : JSONBig.stringify(config.data),
        });

        return fetch(request);
    }
}
